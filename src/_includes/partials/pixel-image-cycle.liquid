<div class="flex justify-center items-center my-6 lg:my-12">
  <div
    id="pixel-image-container-{{ id | default: 'main' }}"
    class="pixel-image-cycle relative w-full max-w-xs aspect-square"
  >
    <!-- Image Container -->
    <div class="image-wrapper absolute inset-0">
      {% if images and images.size > 0 %}
        {% assign initialImageSrc = images[0].src %}
        {% assign initialImageAlt = images[0].alt %}
      {% else %}
        {% assign initialImageSrc = '/images/computer-pixel-art.webp' %}
        {% assign initialImageAlt = 'Computer' %}
      {% endif %}
      <img
        class="current-image w-full h-full object-cover"
        src="{{ initialImageSrc }}"
        alt="{{ initialImageAlt }}"
      >
    </div>

    <!-- Pixel Grid Overlay -->
    <div class="pixel-grid-overlay absolute inset-0 grid">
      <!-- Pixels will be injected here -->
    </div>
  </div>
</div>

<script>
  (function () {
    document.addEventListener('DOMContentLoaded', () => {
      const id = "{{ id | default: 'main' }}";
      const container = document.getElementById(`pixel-image-container-${id}`);
      if (!container) return;

      const currentImage = container.querySelector('.current-image');
      const gridOverlay = container.querySelector('.pixel-grid-overlay');

      if (!gridOverlay || !currentImage) return;

      // Grid Configuration
      const gridSize = 20;

      // Setup Grid CSS
      gridOverlay.style.gridTemplateColumns = `repeat(${gridSize}, 1fr)`;
      gridOverlay.style.gridTemplateRows = `repeat(${gridSize}, 1fr)`;

      // Create Pixels
      const pixels = [];
      for (let i = 0; i < gridSize * gridSize; i++) {
        const px = document.createElement('div');
        px.classList.add('pixel-overlay-item');
        px.style.backgroundColor = 'transparent';
        px.style.opacity = '0';
        px.style.transition = 'opacity 0.4s ease-in-out';
        gridOverlay.appendChild(px);
        pixels.push(px);
      }

      // Image data
      const defaultImages = [
        {
          src: '/images/computer-pixel-art.webp',
          alt: 'Computer',
          color: '#3d60e2',
        },
        {
          src: '/images/coffee-pixel-art.webp',
          alt: 'Coffee',
          color: '#FB8304',
        },
        {
          src: '/images/maple-leaf-pixel-art.webp',
          alt: 'Maple Leaf',
          color: '#FE3300',
        },
        {
          src: '/images/high-five-pixel-art.webp',
          alt: 'High Five',
          color: '#40BFAE',
        },
        {
          src: '/images/canada-goose-pixel-art.webp',
          alt: 'Canada Goose',
          color: '#EDF060',
        },
      ];

      const images = {% if images and images.size > 0 %}{{ images | json }}{% else %}null{% endif %} || defaultImages;

      // Pre-load images to prevent glitches
      images.forEach(img => {
        const preloader = new Image();
        preloader.src = img.src;
      });

      let currentIndex = 0;
      let isTransitioning = false;
      const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)');
      let cycleIntervalId = null;
      let cycleStartTimeoutId = null;

      // Add soft transition to image
      currentImage.style.transition = 'opacity 0.2s ease-in-out';

      function transitionToImage(index) {
        if (isTransitioning || document.hidden || prefersReducedMotion.matches) return;
        isTransitioning = true;

        const nextImage = images[index];
        const transitionColor = nextImage.color;

        const pixelIndices = pixels.map((_, i) => i);
        for (let i = pixelIndices.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [pixelIndices[i], pixelIndices[j]] = [pixelIndices[j], pixelIndices[i]];
        }

        const stagger = 0.8;
        const pixelCoverage = 0.7;
        const pixelMaxOpacity = 0.6;
        const activePixelIndices = pixelIndices.filter(() => Math.random() < pixelCoverage);
        const fadeInStartEnd = activePixelIndices.length * stagger;

        // Phase 1: Pixels fade in
        activePixelIndices.forEach((pixelIdx, i) => {
          setTimeout(() => {
            pixels[pixelIdx].style.backgroundColor = transitionColor;
            pixels[pixelIdx].style.opacity = String(pixelMaxOpacity);
          }, i * stagger);
        });

        // Phase 2: Swap images at peak coverage
        setTimeout(() => {
          currentImage.style.opacity = '0';
          
          // Wait for the tiny fade out to complete
          setTimeout(() => {
            // Setup a one-time load listener for the new image
            const onImageLoad = () => {
              currentImage.removeEventListener('load', onImageLoad);
              currentImage.style.opacity = '1';

              // Phase 3: Reveal immediately after swap
              setTimeout(() => {
                activePixelIndices.forEach((pixelIdx, i) => {
                  setTimeout(() => {
                    pixels[pixelIdx].style.opacity = '0';
                  }, i * stagger);
                });

                setTimeout(() => {
                  isTransitioning = false;
                }, activePixelIndices.length * stagger + 300);
              }, 100); 
            };

            currentImage.addEventListener('load', onImageLoad);
            currentImage.src = nextImage.src;
            currentImage.alt = nextImage.alt;
            
            // Fallback for cached images or load failure
            if (currentImage.complete) {
              onImageLoad();
            }
          }, 200); 
        }, fadeInStartEnd + 50);
      }

      function startCycle() {
        if (cycleIntervalId || prefersReducedMotion.matches) return;
        cycleStartTimeoutId = setTimeout(() => {
          cycleIntervalId = setInterval(() => {
            currentIndex = (currentIndex + 1) % images.length;
            transitionToImage(currentIndex);
          }, 3500);
        }, 1000);
      }

      function stopCycle() {
        if (cycleStartTimeoutId) {
          clearTimeout(cycleStartTimeoutId);
          cycleStartTimeoutId = null;
        }
        if (cycleIntervalId) {
          clearInterval(cycleIntervalId);
          cycleIntervalId = null;
        }
      }

      function syncAnimationState() {
        if (document.hidden || prefersReducedMotion.matches) {
          stopCycle();
          return;
        }

        startCycle();
      }

      syncAnimationState();
      document.addEventListener('visibilitychange', syncAnimationState);
      prefersReducedMotion.addEventListener('change', syncAnimationState);
    });
  })();
</script>
